/**
    (c) Copyright 2014 Hewlett-Packard Development Company, L.P.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
"use strict";
/**
 * Backup helper
 */

var maestro_exec = require('maestro-exec/maestro-exec');
var yaml = require('js-yaml');
var fs   = require('fs');
var async = require('async');
var yamlObj = null;
var yamlMTime = 0;

module.exports = {
  /*
  callback(error):
    On success: error will be null
    On error: error will be not null
  */
  runBackupStatus: function(callback) {
    try {
      //sudo -u forj-bck /usr/lib/forj/sbin/backup-status.p
      var cmd = 'sudo -u forj-bck ' + sails.config.env.backups.backup_status_cmd;
      maestro_exec.execCmd(cmd, function (error, stdout, stderr) {
        if (error){
          callback(new Error('Error running: ' + cmd), stdout, stderr);
        }else{
          callback(null, stdout, stderr);
        }
      });
    } catch (error) {
      callback(error);
    }
  },


  /*
  callback(error, yamlObj):
    On success: error will be null and yamlObj contains javascript Object with backup-status.yaml data
    On error: error will be not null
  */
  getYamlObj: function(callback) {
    try {
      setYamlObj();
      callback(null, yamlObj);
    } catch (error) {
      callback(error);
    }
  },


  /*
  app: Application Name, example gerrit

  callback(error, data):
    On success: error will be null and data has the following items:
      history: history array
      last: Date String
      message: Msg String
      mount-point: String, example /mnt
      path: String
      status: [0: OK, 1: Warning, 2: Error]
      used: Bytes
    On error: error will be not null
  */
  getBackupInfo: function(app, callback) {
    try {
      if (! app){
        throw new Error(app + ' is required.');
      }

      setYamlObj();
      var node = getNode(app);

      if (!yamlObj.backup[node]){
        throw new Error(app + ' has no backups (backup.' + node +' doesnt exist in ' + sails.config.env.backups.backup_status_yaml + ').');
      }

      if (!yamlObj.backup[node][app]){
        throw new Error(app + ' has no backups (backup.' + node +'.'+app+' doesnt exist in ' + sails.config.env.backups.backup_status_yaml + ').');
      }

      callback(null, yamlObj.backup[node][app]);

    } catch (error) {
      callback(error);
    }
  },


  /*
  app: Application Name, example gerrit

  callback(error, weeks):
    On success: error will be null and weeks will be a list of available backup weeks
    On error: error will be not null
  */
  getBackupList: function(app, callback) {
    try {
      if (! app){
        throw new Error('App is required.');
      }

      setYamlObj();

      var node = getNode(app);

      // Example: /mnt/backups/ci.x7.dev.forj.io/jenkins
      var path = sails.config.env.backups.path + '/' + node + '/' + app;

      if (! fs.existsSync(path)){
        throw new Error(app + ' has no backups at: ' + path + '.');
      }

      callback (null, fs.readdirSync(path));

    } catch (error) {
      callback(error);
    }
  },


  /*
  app: Application Name, example gerrit

  callback(error, stdout, stderr):
    On success: error will be null
    On error: error will be not null
  */
  runBackup: function(app, callback) {
    try {
      if (! app){
        throw new Error('App is required.');
      }

      var node = getNode(app);
      // Example /usr/lib/forj/sbin/runbkp.sh /etc/forj/conf.d/bkp_gerrit.conf
      var minionCmd = sails.config.env.backups.runbkp_cmd + ' ' + sails.config.env.backups.conf_dir + '/bkp_' + app + '.conf';
      var saltCmd = "sudo -u salt /usr/bin/salt '" + node + "' --out=yaml cmd.retcode \"" + minionCmd +"\"";
      console.log(saltCmd);
      maestro_exec.execCmd(saltCmd, function (error, stdout, stderr) {
        if(error){
          // Salt Error
          callback(new Error(app + ' backup failed cmd: ' + saltCmd), stdout, stderr );
        } else {
          if (!stdout){
            // Minion cmd failed
            callback( new Error(app + ' backup failed, cmd: ' + saltCmd + ' retcode=BLANK.'), stdout, stderr );
          }

          // Extracting minion retcode
          var retYaml = yaml.safeLoad(stdout);
          if (node in retYaml && retYaml[node].toString() === '0'){
            callback(null, stdout, stderr);
          }else{
            callback( new Error(app + ' backup failed, cmd: ' + minionCmd + ' retcode='+ retYaml[node] +'.'), stdout, stderr );
          }
        }
      });
    } catch (error) {
      callback(error, null, null);
    }
  },


  /*
  callback(error, successMsg):
    On success: error will be null
    On error: error will be not null
  */
  runFullBackup: function(callback) {
    var overallSuccess = true;
    var successMsg = '';
    var errorMsg = '';
    try {
      setYamlObj();

      var services = yamlObj.services;

      if (! services){
        throw new Error ('There are no services in ' + sails.config.env.backups.backup_status_yaml + '.');
      }

      async.forEach(Object.keys(services),
        function(app, callback){
          runBackup(app, function (error) {
            if(error){
              overallSuccess = false;
              errorMsg += app + ' backup failed.\n';
            } else {
              successMsg += app + ' backup completed succesfully.\n';
            }
            // Telling async that we are done
            callback(null);
          });
        },
        // Iteration is done here
        function(err){
          if (err){
            callback(err);
          }else {
            if (overallSuccess){
              callback (null, successMsg);
            }else{
              callback( new Error(errorMsg));
            }
          }
          
        }
      );
    } catch (error) {
      callback(error);
    }
  },


  /*
  app: Application Name, example gerrit
  week: Optional, can be undefined or empty string
  callback(error, stdout, stderr):
    On success: error will be null
    On error: error will be not null
  */
  restore: function(app, week, callback) {
    try {
      if (! app){
        throw new Error('App is required.');
      }

      var node = getNode(app).split(".");
      // Example /usr/lib/forj/sbin/restoreraid.sh -A ci jenkins 2014-30
      var cmd = 'sudo -u salt ' + sails.config.env.backups.restore_cmd + ' -A ' + node[0] + ' ' + app;
      if (week){
        cmd += ' ' + week;
      }
      console.log(cmd);
      maestro_exec.execCmd(cmd, function (error, stdout, stderr) {
        if(error){
          callback(error, stdout, stderr);
        } else {
          callback(null, stdout, stderr);
        }
      });
    } catch (error) {
      callback(error, null, null);
    }
  },


  /*
  app: Application Name, example gerrit
  week: Optional, can be undefined or empty string
  callback(error, stdout, stderr):
    On success: error will be null
    On error: error will be not null
  */
  getLogs: function(app, week, callback) {
    try {
      if (! app){
        throw new Error('App is required.');
      }

      var node = getNode(app);
      var pattern;
      // Get latest week
      if (!week){
        var weekFolders = sails.config.env.backups.path + '/' + node + '/' + app ;
        if (! fs.existsSync(weekFolders)){
          throw new Error(app + ' doesnt have logs at: ' + weekFolders + '.');
        }
        var weekFiles = fs.readdirSync(weekFolders);
        var weeks = 0;
        
        for (var i=0; i<weekFiles.length; i++){
          // yyyy-ww regexp
          pattern = /^\d{4}-\d{2}$/;
          if ( !pattern.test(weekFiles[i]) ) {
            continue;
          }
          var folderYear = weekFiles[i].substring(0,4);
          var folderWeek = weekFiles[i].substring(5,7);
          var currentWeeks = ( parseInt(folderYear) * 48 ) + parseInt(folderWeek);

          if (currentWeeks > weeks){
            weeks = currentWeeks;
            week = weekFiles[i];
          }
        }
      }
      
      if (!week){
        callback (new Error('No logs available.'));
      }
      
      // Example: /mnt/backups/ci.x7.dev.forj.io/jenkins
      var path = sails.config.env.backups.path + '/' + node + '/' + app + '/' + week + '/logs' ;
      if (! fs.existsSync(path)){
          throw new Error(app + ' doesnt have logs at: ' + path + '.');
      }

      var files = fs.readdirSync(path);
      var latestDate = 0;
      var latestLog = '';

      // Get the latest one
      for (var x=0; x<files.length; x++){
        //info_2014-08-24_00-20-02_30556.yaml
        pattern = /^info_\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}_[0-9\(\)]+.yaml$/;
        if ( !pattern.test(files[x]) ) {
          continue;
        }

        var year = files[x].substring(5,9);
        var month = files[x].substring(10,12);
        var day = files[x].substring(13,15); 
        var hours = files[x].substring(16,18);
        var minutes = files[x].substring(19,21);
        var seconds = files[x].substring(22,24);
        var currentDate = Date.UTC(parseInt(year), parseInt(month), parseInt(day), parseInt(hours), parseInt(minutes), parseInt(seconds), 0);

        if (currentDate>latestDate){
          latestDate = currentDate;
          latestLog = files[x];
        }
      }
      if (latestLog){
        var doc = fs.readFileSync(path + '/' + latestLog, 'utf8');
        callback (null, doc);
      }else{
        callback (new Error('No logs available.'));
      }
    } catch (error) {
      callback(error);
    }
  },


  // TODO: Deprecate this function
  get_backup_data: function(){
    var fs   = require('fs');
    try {
      var config = fs.readFileSync('./' + 'config/backup.json');
      config = JSON.parse(config);
      return config;
    } catch (e) {
      return new Error(e.message);
    }
  }

};


// Returns yaml object, or throws exception on error
function setYamlObj(){
    if (! fs.existsSync(sails.config.env.backups.backup_status_yaml)){
      throw new Error(sails.config.env.backups.backup_status_yaml + ' is not ready, try again later.');
    }

    var mTime = fs.statSync(sails.config.env.backups.backup_status_yaml).mtime.getTime(); 

  // The file is loaded one time whenever it is updated.
  if (!yamlObj || mTime != yamlMTime){
    console.log("Loading: " + sails.config.env.backups.backup_status_yaml);
	yamlMTime = mTime;

    var doc = fs.readFileSync(sails.config.env.backups.backup_status_yaml, 'utf8');
    // Remove empty lines that break the yaml
    doc = doc.replace(/^\s*$[\n\r]{1,}/gm, '');
    yamlObj = yaml.safeLoad(doc);
  }
}


// Returns node name String, or throws exception on error
// example: ci.x7.dev.forj.io
function getNode(app){
  if (! app){
    throw new Error('app is required in getNode(app)');
  }

  setYamlObj();
  var node = yamlObj.services[app];

  if (!node){
    throw new Error('Missing ' + app + ' service in '  + sails.config.env.backups.backup_status_yaml + '.');
  }

  return String(node);
}