/**
*# (c) Copyright 2014 Hewlett-Packard Development Company, L.P.
*#
*#   Licensed under the Apache License, Version 2.0 (the "License");
*#   you may not use this file except in compliance with the License.
*#   You may obtain a copy of the License at
*#
*#       http://www.apache.org/licenses/LICENSE-2.0
*#
*#   Unless required by applicable law or agreed to in writing, software
*#   distributed under the License is distributed on an "AS IS" BASIS,
*#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*#   See the License for the specific language governing permissions and
*#   limitations under the License.
*/
'use strict';

var request = require('request');

// Stores metric values in this format:
// cache[node][key].metric = value;
// cache[node][key].retries = 0;
var cache = {};

module.exports = {
  //Returns a Metric Key by doing a request to maestro API
  //callback(error, value):
  //  On success: value will not be undefined
  //  On error: value will be undefined
  getMetric: function(params, node, key, callback) {
    var url = params.endpoint + '/metric/' + node + '/' + key;

    if (!params.endpoint){
        console.error('endpoint is required.');
        callback(null, undefined);
        return;
    }

    if (!params.max_retry){
        console.error('max_retry is required');
        callback(null, undefined);
        return;
    }

    if (!params.timeout){
        console.error('timeout is required');
        callback(null, undefined);
        return;
    }

    if (!node){
      console.error('node is required)');
      callback(null, undefined);
      return;
    }

    if (!key){
      console.error('key is required');
      callback(null, undefined);
      return;
    }

    request({
      uri: url,
      method: 'GET',
      timeout: params.timeout,
    }, function(error, response, body) {
      if (!error) {
        if (response.statusCode === 200){
          var result = JSON.parse(body);
          if (result && result.metric){  // Success
            setCache(node, key, result.metric);
            callback(null, result.metric);
          }else{
            console.error(url + ' didnt returned a Json metric: ' + body);
            callback(null, undefined);
          }
        } else{
          console.error(url + ' response statusCode: ' + response.statusCode);
          callback(null, undefined);
        }
      }else{
        if (error.code === 'ETIMEDOUT'){
          console.error('Maestro api timeout reached: ' + params.timeout + ' node:' + node + ' key: ' + key);
          var cachedMetric;
          var retries = 0;

          if (cache[node] && cache[node][key] ){
            cachedMetric = cache[node][key].metric;
            retries = cache[node][key].retries;
            retries++;
            cache[node][key].retries = retries;
          }

          if (retries > params.max_retry){
            console.error(node + ':' + key + ' metric reached max_retry : ' + params.max_retry );
            callback(null, undefined);
          }else if (cachedMetric!==undefined){
            console.error('Using ' + node + ':' + key + ' cached metric: ' + cachedMetric + ' Retries: ' + retries);
            callback(null, cachedMetric);
          }else {
            callback(null, undefined);
          }
        }else{
          console.error(error.message);
          callback(null, undefined);
        }
      }
    });
  }
};


function setCache(node, key, value){
  if (!cache[node]){
    cache[node] = {};
  }
  if (!cache[node][key]){
    cache[node][key] = {};
  }
  cache[node][key].metric = value;
  cache[node][key].retries = 0;
}